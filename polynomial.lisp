(in-package #:lindsey)

(defconstant TOLERANCE 1e-6)
(defconstant ACCURACY 6)

(defclass Polynomial ()
  ((coefs :initarg :coeff :accessor coefs)
   (var :initarg :var :accessor var :initform "t")
   (s :initarg :s :accessor s)))

(defmethod init ((p Polynomial) cfs)
  (setf (coefs p) (copy-seq cfs)))

(defmethod evaluate ((p Polynomial) x)
  (assert (numberp x) nil "Polynomial evaluate: parameter must be a number.")

  (let ((result 0))
    (loop for i across (coefs p)
       do (setf result (cl:+ (cl:* result x) i)))
    result))

(defmethod degree ((p Polynomial))
  (1- (cl:length (coefs p))))

(defmethod getCubicRoots ((p Polynomial))
  (let ((results (make-array 3 :element-type 'float :fill-pointer 0)))
    (when (= 3 (degree p))
      (let* ((c3 (elt (coefs p) 3))
	     (c2 (cl:/ (elt (coefs p) 2) c3))
	     (c1 (cl:/ (elt (coefs p) 1) c3))
	     (c0 (cl:/ (elt (coefs p) 0) c3))
	     (a  (cl:/ (cl:- (cl:* c1 3) (cl:* c2 c2)) 3))
	     (b  (cl:/ (cl:+ (cl:* 2 c2 c2 c2)
			     (cl:- (cl:* 9 c1 c2))
			     (cl:* 27 c0)) 27))
	     (offset  (cl:/ c2 3))
	     (discrim (cl:+ (cl:/ (cl:* b b) 4)
			    (cl:/ (cl:* a a a) 27)))
	     (halfB (cl:/ b 2)))
	(when (cl:<= (abs discrim) TOLERANCE)
	  (setf discrim 0))
	( cond
	  ((cl:> discrim 0)
	   (let* ((e (sqrt discrim))
		  (tmp (cl:+ (cl:- halfB) e))
		  (root (if (cl:>= tmp 0)
			    (expt tmp 1/3)
			    (cl:- (expt (cl:- tmp) 1/3)))))
	     (setf tmp (cl:+ (cl:- halfB) (cl:- e)))
	     (if (cl:>= tmp 0)
		 (incf root (expt tmp 1/3))
		 (decf root (expt (cl:- tmp) 1/3)))
	     (vector-push root (cl:- root offset))))
	  ((cl:< discrim 0)
	   (let* ((distance (sqrt (cl:/ (cl:- a) 3)))
		  (angle (cl:/
			  (atan (sqrt (cl:- discrim))
				(cl:- halfB))
			  3))
		  (cos (cos angle))
		  (sin (sin angle))
		  (sqrt3 (sqrt 3)))
	     (vector-push (cl:- (cl:* 2 distance cos) offset) results)
	     (vector-push (cl:- (cl:* (cl:- distance)
				      (cl:+ cos (cl:* sqrt3 sin))) offset) results)
	     (vector-push (cl:- (cl:* (cl:- distance)
				      (cl:+ cos (cl:* sqrt3 sin))) offset) results)))
	  (t (let ((tmp (if (cl:>= halfB 0)
			    (cl:- (expt halfB  1/3))
			    (expt (cl:- halfB) 1/3))))
	       (vector-push (cl:- (cl:* 2 tmp) offset) results)
	       (vector-push (cl:- (cl:- tmp) offset) results))))
	results))))

(defmethod getLinearRoot ((p Polynomial))
  (let ((results (make-array 3 :element-type 'float :fill-pointer 0))
	(a (elt (coefs p) 1)))
    (when (cl:/= 0 a)
      (vector-push (cl:/ (cl:- (elt (coefs p) 0)) a) results))
    results))

(defmethod getQuadraticRoots ((p Polynomial))
  (let ((results (make-array 3 :element-type 'float :fill-pointer 0)))
    (when (= (degree p) 2)
      (let* ((a (elt (coefs p) 2))
	     (b (cl:/ (elt (coefs p) 1) a))
	     (c (cl:/ (elt (coefs p) 0) a))
	     (d (cl:- (cl:* b b) (cl:* 4 c))))
	(cond
	  ((cl:> d 0)
	   (let ((e (sqrt d)))
	     (vector-push (cl:* 0.5 (cl:+ (cl:- b) e)) results)
	     (vector-push (cl:* 0.5 (cl:- (cl:- b) e)) results)))
	  ((= d 0)
	   (vector-push (cl:* 0.5 (cl:- b)) results)))))
    results))

(defmethod simplify ((p Polynomial))
  (loop for i from (degree p) downto 0
     do (if (cl:<= (abs (elt (coefs p) i)) TOLERANCE)
	    (vector-pop (coefs p))
	    (return))))

(defmethod getRoots ((p Polynomial))
  (simplify p)
  (case (degree p)
    (0 #())
    (1 (getLinearRoot p))
    (2 (getQuadraticRoots p))
    (3 (getCubicRoots p))
    (otherwise #())))
